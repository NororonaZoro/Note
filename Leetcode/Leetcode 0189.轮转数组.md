# Leetcode 0189.轮转数组

- 标签：数组、数学、双指针
- 难度：中等

- [0189. 轮转数组 - 力扣](https://leetcode.cn/problems/rotate-array/)

**描述**：给定一个数组 *nums*，再给定一个数字 *k*。

**要求**：将数组中的元素向右移动 *k* 个位置。

**说明**：

- 1≤*nums.length*≤105。
- −2(三十一次方)≤nums[i]≤2(三十一次方)−1。
- 0≤*k*≤105。
- 使用空间复杂度为 *O(1)* 的原地算法解决这个问题。

**示例**：

- 示例 1：

```python
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

- 示例 2：

```python
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**解题思路**：

先处理步数 *k*  ，因为数组长度固定，若步数大于数组长度则会出现重复移动的情况

通过对步数进行取余操作，得出真正要走的步数

```python
k %= len(nums)
```

之后笔者拷贝一份数组为后续的移动赋值做准备，但是犯了经典的错误，若直接 *temp = nums* 则相当于引用

而后想起了 *copy* 方法，但是明明笔者记得浅拷贝和深拷贝是不同的，但却误打误撞的到了想要的结果

> 因为数组中都是整数所以是不可变对象，针对不可变对象而言浅拷贝和深拷贝会达到同样的效果
>
> 改变原有数组中的值，新的数组中对应的值并不会改变

```python
temp = nums.copy()
```

之后便是遍历每一个位置的数字，将数字放到移动后的位置，注意末尾的数字要循环移动到队首

所以就要对当前位置加上步数再取余数组长度

**代码**：

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        k %= len(nums)
        temp = nums.copy()
        for i in range(len(nums)):
            nums[(i + k) % len(nums)] = temp[i]
```

